SET search_path TO smart_shell;

-- SELECT current_schema();

-- PROCEDURE AND FUNCTION

DROP PROCEDURE IF EXISTS PR_CREATE_DOCUMENT_TRANSACTION;

CREATE OR REPLACE PROCEDURE PR_CREATE_DOCUMENT_TRANSACTION(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	IN_OBSERV IN VARCHAR,
	IN_COMMEN IN VARCHAR,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_INDEX INTEGER := 1;
BEGIN

	-- CALCULATE INDEX
	BEGIN
		SELECT 
			COALESCE(MAX(INDEX),0) + 1
		INTO STRICT
			V_INDEX
		FROM
			TBL_DOCUMENT_TRANSACTION
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = IN_NUMINT;
			
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				V_INDEX := 1;
	END;

	INSERT INTO TBL_DOCUMENT_TRANSACTION
	SELECT
		DH.IDCOMPANY,
		V_INDEX AS INDEX,
		DH.NUMINT,
		DH.TYPCOMDOC,
		DH.SITCOMDOC,
		DH.SERIE,
		DH.NUMDOC,
		DH.REGISTDATE,
		DH.CODBRANCH,
		DH.CODPLAISS,
		DH.INOUT,
		DH.REACOMDOC,
		DH.BUSNAM,
		DH.ADDRES,
		DH.POSCOD,
		DH.CODCUR,
		DH.EXCHANGERATE,
		DH.INCIGV,
		DH.TASIGV,
		DH.CODSEL,
		DH.TYPPAYCON,
		DH.IMPLISTPRICE,
		DH.IMPDESCTOTAL,
		DH.IMPSALEPRICE,
		DH.IMPTRIBTOTAL,
		DH.IMPTOTAL,
		CASE WHEN V_INDEX = 1 THEN
			'EMMIT DOCUMENT'
		ELSE	
			IN_OBSERV
		END AS OBSERV,
		IN_COMMEN,
		'Y',
		IN_CODUSER,
		IN_CODUSER,
		NOW(),
		NOW()
	FROM TBL_DOCUMENT_HEADER DH
	WHERE
		DH.IDCOMPANY = IN_IDCOMPANY AND
		DH.NUMINT = IN_NUMINT;

	OUT_CODE := 1;
	OUT_MESSAGE := 'THE DOCUMENT [ ' || IN_NUMINT::TEXT || ' ] IS TRANSACTION';
	OUT_LOG := OUT_MESSAGE;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
		RETURN;
END $$;

DROP PROCEDURE IF EXISTS PR_CREATE_GENERATOR_DOCUMENT;

CREATE OR REPLACE PROCEDURE PR_CREATE_GENERATOR_DOCUMENT(
	IN_IDCOMPANY IN INTEGER,
	IN_TYPCOMDOC IN INTEGER,
	IN_SERIE	IN VARCHAR,
	IN_TYPCORREL IN VARCHAR,
	IN_NROCORREL IN INTEGER,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_GEN_DOCUMENT VARCHAR(1000);
BEGIN

	V_GEN_DOCUMENT := 'GEN_' || IN_IDCOMPANY::TEXT || '_' || IN_TYPCOMDOC::TEXT || '_' || IN_SERIE;

	IF IN_TYPCORREL IN ('A','S') THEN
		IF EXISTS (SELECT 1 FROM pg_class WHERE relkind = 'S' AND UPPER(relname) = V_GEN_DOCUMENT) THEN
			OUT_CODE := -2;
			OUT_MESSAGE := 'The generator % already exists!', V_GEN_DOCUMENT;
			OUT_LOG := OUT_MESSAGE;
		ELSE
			EXECUTE 'CREATE SEQUENCE ' || V_GEN_DOCUMENT || ' START ' || IN_NROCORREL;
			OUT_CODE := 1;
			OUT_MESSAGE := 'Generator created successfully';
			OUT_LOG := OUT_MESSAGE;
		END IF;
	ELSE
		OUT_CODE := 0;
		OUT_MESSAGE := 'Manual correlation, generator for the document not created';
		OUT_LOG := OUT_MESSAGE;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
END $$;

-- SEQUENCE BY SERIE
DO $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN
	CALL PR_CREATE_GENERATOR_DOCUMENT(1,1, 'F001'::VARCHAR, 'A'::VARCHAR, 10, V_CODE, V_MESSAGE, V_LOG);
	RAISE NOTICE 'CODE: %', V_CODE;
    RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
	RAISE NOTICE 'LOG: %', V_LOG;
END $$;

DO $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN
	CALL PR_CREATE_GENERATOR_DOCUMENT(1,1, 'F002'::VARCHAR, 'A'::VARCHAR, 10, V_CODE, V_MESSAGE, V_LOG);
	RAISE NOTICE 'CODE: %', V_CODE;
    RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
	RAISE NOTICE 'LOG: %', V_LOG;
END $$;

DO $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN
	CALL PR_CREATE_GENERATOR_DOCUMENT(1,1, 'B001'::VARCHAR, 'A'::VARCHAR, 10, V_CODE, V_MESSAGE, V_LOG);
	RAISE NOTICE 'CODE: %', V_CODE;
    RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
	RAISE NOTICE 'LOG: %', V_LOG;
END $$;


DO $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN
	CALL PR_CREATE_GENERATOR_DOCUMENT(1,1, 'B002'::VARCHAR, 'A'::VARCHAR, 10, V_CODE, V_MESSAGE, V_LOG);
	RAISE NOTICE 'CODE: %', V_CODE;
    RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
	RAISE NOTICE 'LOG: %', V_LOG;
END $$;

-- SEQUENCE BY ALL
CREATE SEQUENCE GEN_1_DOCUMENT START 1000099;

CREATE SEQUENCE GEN_1_KARDEX START 1000099;

DROP PROCEDURE IF EXISTS PR_CREATE_DOCUMENT_HEADER;

CREATE OR REPLACE PROCEDURE PR_CREATE_DOCUMENT_HEADER(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_DOCUMENT IN VARCHAR,
	OUT_NUMINT OUT BIGINT,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_GEN_DOCUMENT VARCHAR(1000);
	V_GEN_TYPEDOCUMENT VARCHAR(1000);
	DOCUMENTJSON JSON;
	V_NUMINT BIGINT := NULL;
	V_CODEXT VARCHAR(100) := NULL;
	V_TYPCOMDOC INTEGER := NULL;
	V_SITCOMDOC INTEGER := NULL;
	V_SERIE VARCHAR(20) := NULL;
	V_NUMDOC BIGINT := 0;
	V_REGISTDATE DATE := NULL;
	V_CODBRANCH INTEGER := NULL;
	V_CODPLAISS INTEGER := NULL;
	V_INOUT INTEGER := NULL;
	V_REACOMDOC INTEGER := NULL;
	V_CODCUR VARCHAR(5) := NULL;
	V_EXCHANGERATE NUMERIC(8,4) := NULL;
	V_CODBUSPAR VARCHAR(50) := NULL;
	V_BUSNAM VARCHAR(250) := NULL;
	V_ADDRES VARCHAR(250) := NULL;
	V_POSCOD VARCHAR(20) := NULL;
	V_CODSEL VARCHAR(50) := NULL;
	V_TYPPAYCON INTEGER := NULL;
	V_INCIGV INTEGER := NULL;
	V_TASIGV NUMERIC(8,4) := NULL;
	V_IMPAFECTO NUMERIC(24,4) := NULL;
	V_IMPINAFECTO NUMERIC(24,4) := NULL;
	V_IMPEXONERADO NUMERIC(24,4) := NULL;
	V_IMPGRATUITO NUMERIC(24,4) := NULL;
	V_IMPIGV NUMERIC(24,4) := NULL;
	V_IMPISC NUMERIC(24,4) := NULL;
	V_IMPTRIBADD01 NUMERIC(24,4) := NULL;
	V_IMPTRIBADD02 NUMERIC(24,4) := NULL;
	V_IMPTRIBADD03 NUMERIC(24,4) := NULL;
	V_IMPTRIBADD04 NUMERIC(24,4) := NULL;
	V_IMPDESC01 NUMERIC(24,4) := NULL;
	V_IMPDESC02 NUMERIC(24,4) := NULL;
	V_IMPDESC03 NUMERIC(24,4) := NULL;
	V_IMPDESC04 NUMERIC(24,4) := NULL;
	V_IMPLISTPRICE NUMERIC(24,4) := NULL;
	V_IMPDESCTOTAL NUMERIC(24,4) := NULL;
	V_IMPSALEPRICE NUMERIC(24,4) := NULL;
	V_IMPTRIBTOTAL NUMERIC(24,4) := NULL;
	V_IMPTOTAL NUMERIC(24,4) := NULL;
	V_REFERE VARCHAR(1000) := NULL;
	V_OBSERV VARCHAR(1000) := NULL;
BEGIN

	DOCUMENTJSON := IN_DOCUMENT::JSON; 
	V_NUMINT := DOCUMENTJSON->>'numint';
    V_CODEXT := DOCUMENTJSON->>'codext';
    V_TYPCOMDOC := DOCUMENTJSON->>'typcomdoc';
    V_SITCOMDOC := DOCUMENTJSON->>'sitcomdoc';
    V_SERIE := DOCUMENTJSON->>'serie';
	V_NUMDOC := DOCUMENTJSON->>'numdoc';
    V_REGISTDATE := DOCUMENTJSON->>'registdate';
    V_CODBRANCH := DOCUMENTJSON->>'codbranch';
    V_CODPLAISS := DOCUMENTJSON->>'codplaiss';
    V_INOUT := DOCUMENTJSON->>'INOUT';
    V_REACOMDOC := DOCUMENTJSON->>'reacomdoc';
    V_CODCUR := DOCUMENTJSON->>'codcur';
	V_EXCHANGERATE := DOCUMENTJSON->>'exchangerate';
    V_CODBUSPAR := DOCUMENTJSON->>'codbuspar';
	V_BUSNAM := DOCUMENTJSON->>'busnam';
	V_ADDRES := DOCUMENTJSON->>'addres';
	V_POSCOD := DOCUMENTJSON->>'poscod';
	V_CODSEL := DOCUMENTJSON->>'codsel';
	V_TYPPAYCON := DOCUMENTJSON->>'typpaycon';
    V_INCIGV := DOCUMENTJSON->>'incigv';
	V_REFERE := DOCUMENTJSON->>'refere';
	V_OBSERV := DOCUMENTJSON->>'observ';
    V_TASIGV := 0;
	IF V_INCIGV = 1 THEN
		BEGIN
			SELECT
				VENTERO
			INTO STRICT
				V_TASIGV		
			FROM
				TBL_COMMERCIAL_FACTOR
			WHERE
				IDCOMPANY = IN_IDCOMPANY AND
				CODCOMFAC = 1;
		EXCEPTION 
			WHEN NO_DATA_FOUND THEN
				OUT_CODE := -1;
				OUT_MESSAGE := 'THERE IS NO COMMERCIAL FACTOR DEFINED FOR THE VAT, REVIEW COMMERCIAL FACTOR NÂ°1';
				OUT_LOG := OUT_MESSAGE;
				RETURN;
		END;
    END IF;
	
	IF V_NUMINT > 0 THEN

		UPDATE TBL_DOCUMENT_HEADER
		SET
			CODEXT = COALESCE(V_CODEXT,CODEXT),
			TYPCOMDOC = COALESCE(V_TYPCOMDOC,TYPCOMDOC),
			SITCOMDOC = COALESCE(V_SITCOMDOC,SITCOMDOC),
			SERIE = COALESCE(V_SERIE,SERIE),
			NUMDOC = COALESCE(V_NUMDOC,NUMDOC),
			REGISTDATE = COALESCE(V_REGISTDATE,REGISTDATE),
			CODBRANCH = COALESCE(V_CODBRANCH,CODBRANCH),
			CODPLAISS = COALESCE(V_CODPLAISS,CODPLAISS),
			INOUT = COALESCE(V_INOUT,INOUT),
			REACOMDOC = COALESCE(V_REACOMDOC,REACOMDOC),
			CODCUR = COALESCE(V_CODCUR,CODCUR),
			EXCHANGERATE = COALESCE(V_EXCHANGERATE,EXCHANGERATE),
			CODBUSPAR = COALESCE(V_CODBUSPAR,CODBUSPAR),
			BUSNAM = COALESCE(V_BUSNAM,BUSNAM),
			ADDRES = COALESCE(V_ADDRES,ADDRES),
			POSCOD = COALESCE(V_POSCOD,POSCOD),
			CODSEL = COALESCE(V_CODSEL,CODSEL),
			TYPPAYCON = COALESCE(V_TYPPAYCON,TYPPAYCON),
			INCIGV = COALESCE(V_INCIGV,INCIGV),
			TASIGV = COALESCE(V_TASIGV,TASIGV),
			IMPAFECTO = COALESCE(V_IMPAFECTO,IMPAFECTO),
			IMPINAFECTO = COALESCE(V_IMPINAFECTO,IMPINAFECTO),
			IMPEXONERADO = COALESCE(V_IMPEXONERADO,IMPEXONERADO),
			IMPGRATUITO = COALESCE(V_IMPGRATUITO,IMPGRATUITO),
			IMPIGV = COALESCE(V_IMPIGV,IMPIGV),
			IMPISC = COALESCE(V_IMPISC,IMPISC),
			IMPTRIBADD01 = COALESCE(V_IMPTRIBADD01,IMPTRIBADD01),
			IMPTRIBADD02 = COALESCE(V_IMPTRIBADD02,IMPTRIBADD02),
			IMPTRIBADD03 = COALESCE(V_IMPTRIBADD03,IMPTRIBADD03),
			IMPTRIBADD04 = COALESCE(V_IMPTRIBADD04,IMPTRIBADD04),
			IMPDESC01 = COALESCE(V_IMPDESC01,IMPDESC01),
			IMPDESC02 = COALESCE(V_IMPDESC02,IMPDESC02),
			IMPDESC03 = COALESCE(V_IMPDESC03,IMPDESC03),
			IMPDESC04 = COALESCE(V_IMPDESC04,IMPDESC04),
			IMPLISTPRICE = COALESCE(V_IMPLISTPRICE,IMPLISTPRICE),
			IMPDESCTOTAL = COALESCE(V_IMPDESCTOTAL,IMPDESCTOTAL),
			IMPSALEPRICE = COALESCE(V_IMPSALEPRICE,IMPSALEPRICE),
			IMPTRIBTOTAL = COALESCE(V_IMPTRIBTOTAL,IMPTRIBTOTAL),
			IMPTOTAL = COALESCE(V_IMPTOTAL,IMPTOTAL),
			REFERE = COALESCE(V_REFERE,REFERE),
			OBSERV = COALESCE(V_OBSERV,OBSERV),
			UPDATEAT = NOW(),
			UPDATEBY = IN_CODUSER
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = V_NUMINT;

		DELETE FROM TBL_DOCUMENT_DETAIL WHERE IDCOMPANY = IN_IDCOMPANY AND NUMINT = V_NUMINT;

	ELSE

		V_GEN_TYPEDOCUMENT := UPPER('GEN_' || IN_IDCOMPANY::TEXT || '_' || V_TYPCOMDOC::TEXT || '_' || V_SERIE);
		V_GEN_DOCUMENT := UPPER('GEN_' || IN_IDCOMPANY::TEXT || '_DOCUMENT');

		IF EXISTS (SELECT 1 FROM pg_class WHERE UPPER(relname) = V_GEN_TYPEDOCUMENT) THEN
			SELECT nextval(V_GEN_TYPEDOCUMENT) INTO V_NUMDOC;
		ELSE
			RAISE EXCEPTION 'THE SEQUENCE % DOES NOT EXIST', V_GEN_TYPEDOCUMENT;
		END IF;

		IF EXISTS (SELECT 1 FROM pg_class WHERE UPPER(relname) = V_GEN_DOCUMENT) THEN
			SELECT nextval(V_GEN_DOCUMENT) INTO V_NUMINT;
		ELSE
			RAISE EXCEPTION 'THE % SEQUENCE DOES NOT EXIST', V_GEN_DOCUMENT;
		END IF;

		INSERT INTO TBL_DOCUMENT_HEADER (
			IDCOMPANY, NUMINT, CODEXT, TYPCOMDOC, SITCOMDOC, SERIE, NUMDOC, REGISTDATE, CODBRANCH, CODPLAISS, INOUT, REACOMDOC,
			CODCUR, EXCHANGERATE, CODBUSPAR, BUSNAM, ADDRES, POSCOD, CODSEL, TYPPAYCON, INCIGV, TASIGV, IMPAFECTO, IMPINAFECTO, IMPEXONERADO, IMPGRATUITO, IMPIGV,
			IMPISC, IMPTRIBADD01, IMPTRIBADD02, IMPTRIBADD03, IMPTRIBADD04, IMPDESC01, IMPDESC02, IMPDESC03,
			IMPDESC04, IMPLISTPRICE, IMPDESCTOTAL, IMPSALEPRICE, IMPTRIBTOTAL, IMPTOTAL, REFERE, OBSERV, CREATEAT, UPDATEAT, CREATEBY, UPDATEBY
		) VALUES (
			IN_IDCOMPANY, V_NUMINT, V_CODEXT, V_TYPCOMDOC, V_SITCOMDOC, V_SERIE, V_NUMDOC, V_REGISTDATE, V_CODBRANCH, V_CODPLAISS, V_INOUT, V_REACOMDOC,
			V_CODCUR, V_EXCHANGERATE, V_CODBUSPAR, V_BUSNAM, V_ADDRES, V_POSCOD, V_CODSEL, V_TYPPAYCON, V_INCIGV, V_TASIGV, V_IMPAFECTO, V_IMPINAFECTO, V_IMPEXONERADO, V_IMPGRATUITO, V_IMPIGV,
			V_IMPISC, V_IMPTRIBADD01, V_IMPTRIBADD02, V_IMPTRIBADD03, V_IMPTRIBADD04, V_IMPDESC01, V_IMPDESC02, V_IMPDESC03,
			V_IMPDESC04, V_IMPLISTPRICE, V_IMPDESCTOTAL, V_IMPSALEPRICE, V_IMPTRIBTOTAL, V_IMPTOTAL, V_REFERE, V_OBSERV, NOW(), NOW(), IN_CODUSER, IN_CODUSER
		);

	END IF;

	OUT_NUMINT := V_NUMINT;
	OUT_CODE := 0;
	OUT_MESSAGE := 'THE DOCUMENT [ ' || V_NUMINT::TEXT || ' ] IT HAS BEEN GENERATED WITH THE SERIES AND NUMBER ' || V_SERIE || '-' || V_NUMDOC::TEXT;
	OUT_LOG := OUT_MESSAGE;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		OUT_NUMINT := V_NUMINT;
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
	RETURN;
END $$;

-- DO $$
-- DECLARE
-- 	V_DOCUMENT VARCHAR(4000) := '{"numint":null,"codext":"","typcomdoc":1,"sitcomdoc":1,"serie":"F001","numdoc":null,
-- 	"registdate":[2023,4,28],
-- 	"codbranch":1,
-- 	"codplaiss":1,
-- 	"INOUT":1,
-- 	"reacomdoc":1,
-- 	"codcur":"PEN",
-- 	"exchangerate":3.89,
-- 	"codbuspar":"65498732",
-- 	"busnam":"Pedro Castillo Chavez",
-- 	"addres":"Av. Tacna 1213",
-- 	"poscod":"000000",
-- 	"codsel":"6800194159",
-- 	"typpaycon":1,
-- 	"incigv":1}';
-- 	V_NUMINT BIGINT;
-- 	V_CODE INTEGER;
-- 	V_MESSAGE VARCHAR(1000);
-- 	V_LOG VARCHAR(1000);
-- BEGIN
-- 	CALL PR_CREATE_DOCUMENT_HEADER(V_DOCUMENT, V_NUMINT, V_CODE, V_MESSAGE, V_LOG);
-- 	RAISE NOTICE 'NUMINT : %',V_NUMINT;
-- 	RAISE NOTICE 'CODE: %', V_CODE;
--     RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
-- 	RAISE NOTICE 'LOG: %', V_LOG;
-- END $$;

SELECT * FROM TBL_DOCUMENT_HEADER;

DROP PROCEDURE IF EXISTS PR_CREATE_DOCUMENT_DETAIL;

CREATE OR REPLACE PROCEDURE PR_CREATE_DOCUMENT_DETAIL(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_DOCUMENT IN VARCHAR,
	OUT_NUMITE OUT BIGINT,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	DOCUMENTJSON JSON;
	V_NUMINT BIGINT := NULL;
	V_NUMITE BIGINT := NULL;
	V_TYPINV INTEGER := NULL;
    V_CODART VARCHAR(50) := NULL;
    V_ETIQUETA BIGINT := NULL;
	V_QUANTITY NUMERIC(24,4) := NULL;
	V_PRICE NUMERIC(24,4) := NULL;
	V_IMPAFECTO NUMERIC(24,4) := NULL;
	V_IMPINAFECTO NUMERIC(24,4) := NULL;
	V_IMPEXONERADO NUMERIC(24,4) := NULL;
	V_IMPGRATUITO NUMERIC(24,4) := NULL;
	V_IMPIGV NUMERIC(24,4) := NULL;
	V_IMPISC NUMERIC(24,4) := NULL;
	V_IMPTRIBADD01 NUMERIC(24,4) := NULL;
	V_IMPTRIBADD02 NUMERIC(24,4) := NULL;
	V_IMPTRIBADD03 NUMERIC(24,4) := NULL;
	V_IMPTRIBADD04 NUMERIC(24,4) := NULL;
	V_IMPDESC01 NUMERIC(24,4) := NULL;
	V_IMPDESC02 NUMERIC(24,4) := NULL;
	V_IMPDESC03 NUMERIC(24,4) := NULL;
	V_IMPDESC04 NUMERIC(24,4) := NULL;
	V_IMPLISTPRICE NUMERIC(24,4) := NULL;
	V_IMPDESCTOTAL NUMERIC(24,4) := NULL;
	V_IMPSALEPRICE NUMERIC(24,4) := NULL;
	V_IMPTRIBTOTAL NUMERIC(24,4) := NULL;
	V_IMPTOTAL NUMERIC(24,4) := NULL;
	V_AUX1 NUMERIC(24,4) := NULL;
BEGIN

	DOCUMENTJSON := IN_DOCUMENT::JSON; 
	V_NUMINT := DOCUMENTJSON->>'numint';
	V_NUMITE := DOCUMENTJSON->>'numite';
	V_TYPINV := DOCUMENTJSON->>'typinv';
	V_CODART := DOCUMENTJSON->>'codart';
	V_ETIQUETA := DOCUMENTJSON->>'etiqueta';
	V_QUANTITY := DOCUMENTJSON->>'quantity';
	V_PRICE := DOCUMENTJSON->>'price';
	V_IMPAFECTO := DOCUMENTJSON->>'impafecto';
	V_IMPINAFECTO := DOCUMENTJSON->>'impinafecto';
	V_IMPEXONERADO := DOCUMENTJSON->>'impexonerado';
	V_IMPGRATUITO := DOCUMENTJSON->>'impgratuito';
	V_IMPDESC01 := DOCUMENTJSON->>'impdesc01';
	V_IMPDESC02 := DOCUMENTJSON->>'impdesc02';
	V_IMPDESC03 := DOCUMENTJSON->>'impdesc03';
	V_IMPDESC04 := DOCUMENTJSON->>'impdesc04';
	
	IF V_QUANTITY <= 0 AND (V_IMPAFECTO + V_IMPINAFECTO + V_IMPEXONERADO + V_IMPGRATUITO) <= 0 THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'The amount and/or quantity cannot be less than or equal to zero';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
    END IF;
	
	-- IF NOT EXISTS(SELECT DH.NUMINT FROM TBL_DOCUMENT_HEADER DH WHERE DH.IDCOMPANY = IN_IDCOMPANY AND DH.NUMINT = V_NUMINT) THEN
	-- 	OUT_CODE := -2;
	-- 	OUT_MESSAGE := 'The document [ ' || V_NUMINT::TEXT || ' ] does not exists';
	-- 	OUT_LOG := OUT_MESSAGE;
	-- 	RETURN;
	-- END IF;

	BEGIN
		SELECT
			( DD.NUMITE + 1 )
		INTO STRICT	
			V_NUMITE
		FROM TBL_DOCUMENT_DETAIL DD
		WHERE
			DD.IDCOMPANY = IN_IDCOMPANY AND
			DD.NUMINT = V_NUMINT
		ORDER BY
			DD.NUMITE DESC
		FETCH NEXT 1 ROWS ONLY;
		
	EXCEPTION
		WHEN no_data_found THEN
			V_NUMITE = 1;
	END;

	-- CALCULATE IMPORT
	V_IMPLISTPRICE := COALESCE(V_IMPAFECTO,0) + COALESCE(V_IMPINAFECTO,0) + COALESCE(V_IMPEXONERADO,0) + COALESCE(V_IMPGRATUITO,0);
	V_AUX1 := (1 - COALESCE(V_IMPDESC01,0)) * (1 - COALESCE(V_IMPDESC02,0)) * (1 - COALESCE(V_IMPDESC03,0)) * (1 - COALESCE(V_IMPDESC04,0));
	V_IMPDESCTOTAL := V_IMPLISTPRICE - (V_IMPLISTPRICE * V_AUX1);
	V_IMPSALEPRICE := V_IMPLISTPRICE - V_IMPDESCTOTAL;

	V_IMPIGV := V_IMPAFECTO * (V_AUX1) * 0.18;
	V_IMPISC := 0;
	V_IMPTRIBADD01 := 0;
	V_IMPTRIBADD02 := 0;
	V_IMPTRIBADD03 := 0;
	V_IMPTRIBADD04 := 0;
	
	V_IMPTRIBTOTAL := V_IMPIGV + V_IMPISC + V_IMPTRIBADD01 + V_IMPTRIBADD02 + V_IMPTRIBADD03 + V_IMPTRIBADD04;
	V_IMPTOTAL := V_IMPSALEPRICE + V_IMPTRIBTOTAL;

	INSERT INTO TBL_DOCUMENT_DETAIL ( 
		IDCOMPANY, NUMINT, NUMITE, TYPINV, CODART, ETIQUETA, QUANTITY, PRICE, IMPAFECTO, IMPINAFECTO, IMPEXONERADO, IMPGRATUITO, IMPIGV,
		IMPISC, IMPTRIBADD01, IMPTRIBADD02, IMPTRIBADD03, IMPTRIBADD04, IMPDESC01, IMPDESC02, IMPDESC03,
		IMPDESC04, IMPLISTPRICE, IMPDESCTOTAL, IMPSALEPRICE, IMPTRIBTOTAL, IMPTOTAL, CREATEAT, UPDATEAT, CREATEBY, UPDATEBY
	) VALUES (
		IN_IDCOMPANY, V_NUMINT, V_NUMITE, V_TYPINV, V_CODART, V_ETIQUETA, V_QUANTITY, V_PRICE, V_IMPAFECTO, V_IMPINAFECTO, V_IMPEXONERADO, V_IMPGRATUITO, V_IMPIGV,
		V_IMPISC, V_IMPTRIBADD01, V_IMPTRIBADD02, V_IMPTRIBADD03, V_IMPTRIBADD04, V_IMPDESC01, V_IMPDESC02, V_IMPDESC03,
		V_IMPDESC04, V_IMPLISTPRICE, V_IMPDESCTOTAL, V_IMPSALEPRICE, V_IMPTRIBTOTAL, V_IMPTOTAL, NOW(), NOW(), IN_CODUSER, IN_CODUSER
	);

	OUT_CODE := 1;
	OUT_MESSAGE := 'The documento [ ' || V_NUMINT::TEXT || ' - ' || V_NUMITE::TEXT || ' ] has been generated';
	OUT_LOG := OUT_MESSAGE;
	OUT_NUMITE := V_NUMITE;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
		OUT_NUMITE := V_NUMITE;
		RETURN;
END $$;
 
-- DO $$
-- DECLARE
-- 	V_DOCUMENT VARCHAR(4000) := 
-- 		'{"numint":88,
-- 		"typinv":1,
-- 		"codart":"OSAHG",
-- 		"etiqueta":"5459821654",
-- 		"quantity":1,
-- 		"price":10.00,
-- 		"impafecto":10.00,
-- 		"impinafecto":0,
-- 		"impexonerado":0,
-- 		"impgratuito":0,
-- 		"impdesc01":0.10,
-- 		"impdesc02":0.15,
-- 		"impdesc03":0,
-- 		"impdesc04":0}';
-- 	V_NUMITE BIGINT;
-- 	V_CODE INTEGER;
-- 	V_MESSAGE VARCHAR(1000);
-- 	V_LOG VARCHAR(1000);
-- BEGIN
-- 	CALL PR_CREATE_DOCUMENT_DETAIL(V_DOCUMENT, V_NUMITE, V_CODE, V_MESSAGE, V_LOG);
-- 	RAISE NOTICE 'NUMITE: %', V_NUMITE;
-- 	RAISE NOTICE 'CODE: %', V_CODE;
--     RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
-- 	RAISE NOTICE 'LOG: %', V_LOG;
-- END $$;

SELECT * FROM TBL_DOCUMENT_DETAIL;

DROP PROCEDURE IF EXISTS PR_CALCULATE_IMPORT_DOCUMENT;

CREATE OR REPLACE PROCEDURE PR_CALCULATE_IMPORT_DOCUMENT(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_IMPLISTPRICE NUMERIC(24,4) := 0;
	V_IMPDESCTOTAL NUMERIC(24,4) := 0;
	V_IMPSALEPRICE NUMERIC(24,4) := 0;
	V_IMPTRIBTOTAL NUMERIC(24,4) := 0;
	V_IMPTOTAL NUMERIC(24,4) := 0;
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN

	IF NOT EXISTS (SELECT DH.NUMINT FROM TBL_DOCUMENT_HEADER DH WHERE DH.IDCOMPANY = IN_IDCOMPANY AND DH.NUMINT = IN_NUMINT ) THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'Record with ID [ ' || IN_NUMINT::VARCHAR || ' ] does not exists';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
	ELSE
		SELECT
			SUM(DD.IMPLISTPRICE),
			SUM(DD.IMPDESCTOTAL),
			SUM(DD.IMPSALEPRICE),
			SUM(DD.IMPTRIBTOTAL),
			SUM(DD.IMPTOTAL)
		INTO STRICT
			V_IMPLISTPRICE,
			V_IMPDESCTOTAL,
			V_IMPSALEPRICE,
			V_IMPTRIBTOTAL,
			V_IMPTOTAL
		FROM TBL_DOCUMENT_DETAIL DD
		WHERE 
			DD.IDCOMPANY = IN_IDCOMPANY AND
			DD.NUMINT = IN_NUMINT;
		
		UPDATE TBL_DOCUMENT_HEADER
		SET
			IMPLISTPRICE = V_IMPLISTPRICE,
			IMPDESCTOTAL = V_IMPDESCTOTAL,
			IMPSALEPRICE = V_IMPSALEPRICE,
			IMPTRIBTOTAL = V_IMPTRIBTOTAL,
			IMPTOTAL = V_IMPTOTAL,
			UPDATEAT = NOW(),
			UPDATEBY = IN_CODUSER
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = IN_NUMINT;

		CALL PR_CREATE_DOCUMENT_TRANSACTION(IN_IDCOMPANY, IN_CODUSER, IN_NUMINT, 'MODIFY DOCUMENT','', V_CODE, V_MESSAGE, V_LOG);
		
		IF V_CODE <> 1 THEN
			OUT_CODE := V_CODE;
			OUT_MESSAGE := V_MESSAGE;
			OUT_LOG := V_LOG;
			RETURN;
		END IF;

		OUT_CODE := 1;
		OUT_MESSAGE := 'THE DOCUMENT [ ' || IN_NUMINT::TEXT || ' ] IS CALCULATED';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
		
	END IF;	
	
EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
END $$;

-- DO $$
-- DECLARE
-- 	V_CODE INTEGER;
-- 	V_MESSAGE VARCHAR(1000);
-- 	V_LOG VARCHAR(1000);
-- BEGIN
-- 	CALL PR_CALCULATE_IMPORT_DOCUMENT(1, 'ADMIN', 88, V_CODE, V_MESSAGE, V_LOG);
-- 	RAISE NOTICE 'CODE: %', V_CODE;
--     RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
-- 	RAISE NOTICE 'LOG: %', V_LOG;
-- END $$;

SELECT * FROM  TBL_DOCUMENT_HEADER;

DROP FUNCTION IF EXISTS FN_SEARCH_DOCUMENT;

DROP TYPE IF EXISTS REC_SEARCH_DOCUMENT;

CREATE TYPE REC_SEARCH_DOCUMENT AS (
	NUMINT BIGINT,
	NUMDOC BIGINT,
	SERIE  VARCHAR(5),
	TYPCOMDOC INTEGER,
	DESTYPCOMDOC VARCHAR(10),
	SITCOMDOC INTEGER,
	DESSITCOMDOC VARCHAR(10),
	REGISTDATE DATE,
	INOUT INTEGER,
	DESINOUT VARCHAR(10),
	REACOMDOC INTEGER,
	DESREACOMDOC VARCHAR(10),
	CODBUSPAR VARCHAR(50),
	BUSNAM VARCHAR(250),
	ADDRES VARCHAR(250),
	DESPLAISS VARCHAR(10),
	CODCUR VARCHAR(5),
	DESSEL VARCHAR(10),
	DESTYPPAYCON VARCHAR(10),
	IMPSALEPRICE NUMERIC(24,4),
	IMPTOTAL NUMERIC(24,4)	
);

CREATE OR REPLACE FUNCTION FN_SEARCH_DOCUMENT(
	IN_IDCOMPANY IN INTEGER,
	-- OBLIGATORIO
	IN_TYPCOMDOC IN INTEGER,
	IN_STARTAT IN DATE,
	IN_FINALAT IN DATE,
	-- RANGO MULTYPLE
	IN_SITCOMDOC IN TEXT,
	IN_REACOMDOC IN TEXT,
	-- OPCIONAL
	IN_SERIE IN VARCHAR,
	IN_TYPPAYCON IN INTEGER, 
	IN_CODBUSPAR IN VARCHAR
)
RETURNS SETOF REC_SEARCH_DOCUMENT AS
$BODY$
BEGIN
	RETURN QUERY
	SELECT
		DH.NUMINT,
		DH.NUMDOC,
		DH.SERIE,
		TDC.TYPCOMDOC,
		TDC.ABREVI AS DESTYPCOMDOC,
		SDC.SITCOMDOC,
		SDC.ABREVI AS DESSITCOMDOC,
		DH.REGISTDATE,
		DH.INOUT,
		CAST(CASE WHEN DH.INOUT = 0 THEN
			'Ingreso'
		ELSE
			'Salida'		
		END AS VARCHAR(10)) DESINOUT,
		MDC.REACOMDOC,
		MDC.ABREVI AS DESREACOMDOC,
		DH.CODBUSPAR,
		DH.BUSNAM,
		DH.ADDRES,
		CAST(CASE WHEN DH.CODPLAISS = 1 THEN
			'Punt Venta'
		ELSE
			'ND'
		END AS VARCHAR(10)) DESPLAISS,
		DH.CODCUR,
		S.ABREVI AS DESSEL,
		TCP.ABREVI AS DESTYPPAYCON,
		DH.IMPSALEPRICE,
		DH.IMPTOTAL
	FROM TBL_DOCUMENT_HEADER DH
	LEFT OUTER JOIN TBL_TYPE_COMMERCIAL_DOCUMENT TDC ON TDC.IDCOMPANY = DH.IDCOMPANY AND TDC.TYPCOMDOC = DH.TYPCOMDOC
	LEFT OUTER JOIN TBL_SITUATION_COMMERCIAL_DOCUMENT SDC ON SDC.IDCOMPANY = DH.IDCOMPANY AND SDC.TYPCOMDOC =  DH.TYPCOMDOC AND SDC.SITCOMDOC = DH.SITCOMDOC
	LEFT OUTER JOIN TBL_REASON_COMMERCIAL_DOCUMENT MDC ON MDC.IDCOMPANY = DH.IDCOMPANY AND MDC.TYPCOMDOC =  DH.TYPCOMDOC AND MDC.INOUT = DH.INOUT AND MDC.REACOMDOC =  DH.REACOMDOC
	LEFT OUTER JOIN TBL_SELLER S ON S.IDCOMPANY = DH.IDCOMPANY AND S.CODSEL = DH.CODSEL
	LEFT OUTER JOIN TBL_TYPE_PAYMENT_CONDITION TCP ON TCP.IDCOMPANY = DH.IDCOMPANY AND TCP.TYPPAYCON = DH.TYPPAYCON
	WHERE
		DH.IDCOMPANY = IN_IDCOMPANY AND
		DH.TYPCOMDOC = IN_TYPCOMDOC AND
		DH.REGISTDATE BETWEEN IN_STARTAT AND IN_FINALAT AND
		DH.SITCOMDOC IN (SELECT CAST(regexp_split_to_table(IN_SITCOMDOC, '\,') AS NUMERIC)) AND
		DH.REACOMDOC IN (SELECT CAST(regexp_split_to_table(IN_REACOMDOC, '\,') AS NUMERIC)) AND
		( IN_SERIE = '-1' OR DH.SERIE = IN_SERIE ) AND
		( IN_TYPPAYCON = -1 OR DH.TYPPAYCON = IN_TYPPAYCON ) AND
		( IN_CODBUSPAR = '-1' OR DH.CODBUSPAR = IN_CODBUSPAR )
	ORDER BY
		DH.NUMINT DESC;
		
END;
$BODY$
LANGUAGE plpgsql;

-- SELECT * FROM FN_SEARCH_DOCUMENT(1,
-- 								  TO_DATE('2023-03-01', 'YYYY-MM-DD'),
-- 								  TO_DATE('2023-06-03', 'YYYY-MM-DD'),'1,2,3,4,5','1,2,3,4,5',NULL,NULL,NULL);

DROP FUNCTION IF EXISTS FN_PRINT_DOCUMENT_INVOCE;

DROP TYPE IF EXISTS REC_PRINT_DOCUMENT_INVOCE;

CREATE TYPE REC_PRINT_DOCUMENT_INVOCE AS (
	-- PRINT
	TYPFORMAT INTEGER,
	TYPCOMDOC INTEGER,
	-- COMPANY
	COMDESTYPIDEDOC VARCHAR(250),
	COMNROIDEDOC VARCHAR(100), 
	COMNAM VARCHAR(250),
	COMADDRES VARCHAR(250),
	COMPOSCOD VARCHAR(20), 
	COMGLOSS BYTEA,
	-- HEADER
	NUMINT BIGINT,
	NUMDOC BIGINT,
	SERIE  VARCHAR(5),
	DESDOCCOM VARCHAR(250),
	DESSITCOMDOC VARCHAR(250),
	REGISTDATE DATE,
	DESINOUT VARCHAR(250),
	DESREACOMDOC VARCHAR(250),
	CODBUSPAR VARCHAR(50),
	DESTYPIDEDOC VARCHAR(250),
	NROIDEDOC VARCHAR(100),
	BUSNAM VARCHAR(250),
	ADDRES VARCHAR(250),
	POSCOD VARCHAR(20),
	DESPLAISS VARCHAR(250),
	-- CURRENCY
	CODCUR VARCHAR(5),
	CURSYMBOL VARCHAR(5),
	EXCHANGERATE NUMERIC(8,4),
	DESSEL VARCHAR(250),
	DESPAYCON VARCHAR(250),
	-- REFERE
	REFERE VARCHAR(1000),
	OBSERV VARCHAR(1000),
	COMMEN VARCHAR(1000),
	IMPLISTPRICE NUMERIC(24,4),
    IMPDESCTOTAL NUMERIC(24,4),
    IMPSALEPRICE NUMERIC(24,4),
	IMPTRIBTOTAL NUMERIC(24,4),
    IMPTOTAL NUMERIC(24,4),
	IMPNAME VARCHAR(250),
	-- DETAIL
	NUMITE BIGINT,
    TYPINV INTEGER,
	DESTYPINV VARCHAR(250),
    CODART VARCHAR(50),
    DESART VARCHAR(250),
	ETIQUETA BIGINT,
	DESETIQUETA VARCHAR(250),
	QUANTITY NUMERIC(24,4),
	PRICE NUMERIC(24,4),	
	DETLISTPRICE NUMERIC(24,4),
    DETDESCTOTAL NUMERIC(24,4),
    DETSALEPRICE NUMERIC(24,4),
	DETTRIBTOTAL NUMERIC(24,4),
	DETTOTAL NUMERIC(24,4)
);

CREATE OR REPLACE FUNCTION FN_PRINT_DOCUMENT_INVOCE(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT
)
RETURNS SETOF REC_PRINT_DOCUMENT_INVOCE AS
$BODY$
BEGIN
	RETURN QUERY
	SELECT
		-- PRINT FORMAT
		COALESCE(SCD.TYPFORMAT,0),
		COALESCE(SCD.TYPCOMDOC,0),
		-- COMPANY
		TID1.DESCRI AS COMDESTYPIDEDOC,
		CI.COMPANY AS COMNROIDEDOC,
		CI.APPELLATION AS COMNAM,
		CI.ADDRES AS COMADDRES,
		CI.POSCOD AS COMPOSCOD,
		CI.GLOSS AS COMGLOSS,
		-- HEADER
		DH.NUMINT,
		DH.NUMDOC,
		DH.SERIE,
		TDC.DESCRI AS DESDOCCOM,
		SDC.DESCRI AS DESSITCOMDOC,
		DH.REGISTDATE,
		CAST(CASE WHEN DH.INOUT = 0 THEN
			'Ingreso'
		ELSE
			'Salida'		
		END AS VARCHAR(250)) AS DESINOUT,
		MDC.DESCRI AS DESREACOMDOC,
		DH.CODBUSPAR,
		TID2.DESCRI AS DESTYPCOMDOC,
		BP.NROIDEDOC, 
		DH.BUSNAM,
		DH.ADDRES,
		DH.POSCOD,
		CAST(CASE WHEN DH.CODPLAISS = 1 THEN
			'Punt Venta'
		ELSE
			'ND'
		END AS VARCHAR(250)) AS DESPLAISS,
		DH.CODCUR,
		C.SYMBOL AS CURSYMBOL,
		DH.EXCHANGERATE,
		S.DESCRI AS DESSEL,
		TCP.DESCRI AS DESPAYCON,
		-- REFERE
		DH.REFERE,
		DH.OBSERV,
		DH.COMMEN,
		DH.IMPLISTPRICE,
		DH.IMPDESCTOTAL,
		DH.IMPSALEPRICE,
		DH.IMPTRIBTOTAL,
		DH.IMPTOTAL,
	 	CAST(UPPER(number_to_string(DH.IMPTOTAL) || ' ' || C.DESCRI) AS VARCHAR(250)) AS IMPNAME, 
		-- DETAILS
		DD.NUMITE,
		DD.TYPINV,
		TI.DESCRI AS DESTYPINV,
		DD.CODART,
		A.DESCRI AS DESART,
		DD.ETIQUETA,
		CAST('' AS VARCHAR(250)) AS DESETIQUETA,
		DD.QUANTITY,
		DD.PRICE,
		DD.IMPLISTPRICE AS DETLISTPRICE,
		DD.IMPDESCTOTAL AS DETDESCTOTAL,
		DD.IMPSALEPRICE AS DETSALEPRICE,
		DD.IMPTRIBTOTAL AS DETTRIBTOTAL,
		DD.IMPTOTAL AS DETTOTAL
	FROM TBL_DOCUMENT_HEADER DH
	LEFT OUTER JOIN TBL_SERIE_COMMERCIAL_DOCUMENT SCD ON SCD.IDCOMPANY = DH.IDCOMPANY AND SCD.TYPCOMDOC = DH.TYPCOMDOC AND SCD.SERIE = DH.SERIE
	LEFT OUTER JOIN TBL_COMPANY_INFO CI ON CI.IDCOMPANY = DH.IDCOMPANY
	LEFT OUTER JOIN TBL_TYPE_IDENTITY_DOCUMENT TID1 ON TID1.IDCOMPANY = DH.IDCOMPANY AND TID1.TYPIDEDOC = 2
	LEFT OUTER JOIN TBL_BUSINESS_PARTNER BP ON BP.IDCOMPANY = DH.IDCOMPANY AND BP.CODBUSPAR = DH.CODBUSPAR
	LEFT OUTER JOIN TBL_TYPE_IDENTITY_DOCUMENT TID2 ON TID2.IDCOMPANY = DH.IDCOMPANY AND TID2.TYPIDEDOC = BP.TYPIDEDOC
	LEFT OUTER JOIN TBL_TYPE_COMMERCIAL_DOCUMENT TDC ON TDC.IDCOMPANY = DH.IDCOMPANY AND TDC.TYPCOMDOC = DH.TYPCOMDOC
	LEFT OUTER JOIN TBL_SITUATION_COMMERCIAL_DOCUMENT SDC ON SDC.IDCOMPANY = DH.IDCOMPANY AND SDC.TYPCOMDOC =  DH.TYPCOMDOC AND SDC.SITCOMDOC = DH.SITCOMDOC
	LEFT OUTER JOIN TBL_REASON_COMMERCIAL_DOCUMENT MDC ON MDC.IDCOMPANY = DH.IDCOMPANY AND MDC.TYPCOMDOC =  DH.TYPCOMDOC AND MDC.INOUT = DH.INOUT AND MDC.REACOMDOC =  DH.REACOMDOC
	LEFT OUTER JOIN TBL_SELLER S ON S.IDCOMPANY = DH.IDCOMPANY AND S.CODSEL = DH.CODSEL
	LEFT OUTER JOIN TBL_CURRENCY C ON C.IDCOMPANY = DH.IDCOMPANY AND C.CODCUR = DH.CODCUR
	LEFT OUTER JOIN TBL_TYPE_PAYMENT_CONDITION TCP ON TCP.IDCOMPANY = DH.IDCOMPANY AND  TCP.TYPPAYCON = DH.TYPPAYCON
	LEFT OUTER JOIN TBL_DOCUMENT_DETAIL DD ON DD.IDCOMPANY = DH.IDCOMPANY AND DD.NUMINT = DH.NUMINT
	LEFT OUTER JOIN TBL_TYPE_INVENTORY TI ON TI.IDCOMPANY = DD.IDCOMPANY AND TI.TYPINV = DD.TYPINV
	LEFT OUTER JOIN TBL_ARTICLE A ON A.IDCOMPANY = DD.IDCOMPANY AND A.CODART = DD.CODART
	WHERE
		DH.IDCOMPANY = IN_IDCOMPANY AND
		DH.NUMINT = IN_NUMINT
	ORDER BY
		DD.NUMITE ASC;
	
END;
$BODY$
LANGUAGE plpgsql;

-- SELECT * FROM FN_PRINT_DOCUMENT_INVOCE(88);

DROP PROCEDURE IF EXISTS PR_CANCEL_INVOICE;

CREATE OR REPLACE PROCEDURE PR_CANCEL_INVOICE(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	IN_COMMEN IN VARCHAR,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN

	IF NOT EXISTS (SELECT DH.NUMINT FROM TBL_DOCUMENT_HEADER DH WHERE DH.IDCOMPANY = IN_IDCOMPANY AND DH.NUMINT = IN_NUMINT ) THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'Record with ID [ ' || IN_NUMINT::VARCHAR || ' ] does not exists';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
	ELSE		
		UPDATE TBL_DOCUMENT_HEADER
		SET
			SITCOMDOC = 4,
			UPDATEBY = IN_CODUSER,
			UPDATEAT = NOW()
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = IN_NUMINT;

		CALL PR_CREATE_DOCUMENT_TRANSACTION(IN_IDCOMPANY, IN_CODUSER, IN_NUMINT, 'CANCEL DOCUMENT', IN_COMMEN, V_CODE, V_MESSAGE, V_LOG);
		
		IF V_CODE <> 1 THEN
			OUT_CODE := V_CODE;
			OUT_MESSAGE := V_MESSAGE;
			OUT_LOG := V_LOG;
			RETURN;
		END IF;

		OUT_CODE := 1;
		OUT_MESSAGE := 'SUCCESSFUL CANCELLATION';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
		
	END IF;	
	
EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
END $$;

DROP PROCEDURE IF EXISTS PR_DELETE_INVOICE;

CREATE OR REPLACE PROCEDURE PR_DELETE_INVOICE(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	IN_COMMEN IN VARCHAR,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN

	IF NOT EXISTS (SELECT DH.NUMINT FROM TBL_DOCUMENT_HEADER DH WHERE DH.IDCOMPANY = IN_IDCOMPANY AND DH.NUMINT = IN_NUMINT ) THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'Record with ID [ ' || IN_NUMINT::VARCHAR || ' ] does not exists';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
	ELSE		
		UPDATE TBL_DOCUMENT_HEADER
		SET
			SITCOMDOC = 5,
			NUMDOC = 0,
			UPDATEBY = IN_CODUSER,
			UPDATEAT = NOW()
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = IN_NUMINT;
			
		CALL PR_CREATE_DOCUMENT_TRANSACTION(IN_IDCOMPANY, IN_CODUSER, IN_NUMINT, 'DELETE DOCUMENT', IN_COMMEN, V_CODE, V_MESSAGE, V_LOG);
		
		IF V_CODE <> 1 THEN
			OUT_CODE := V_CODE;
			OUT_MESSAGE := V_MESSAGE;
			OUT_LOG := V_LOG;
			RETURN;
		END IF;

		OUT_CODE := 1;
		OUT_MESSAGE := 'SUCCESSFUL DELETION';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
		
	END IF;	
	
EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
END $$;

-- DO $$
-- DECLARE
-- 	V_CODE INTEGER;
-- 	V_MESSAGE VARCHAR(1000);
-- 	V_LOG VARCHAR(1000);
-- BEGIN
-- 	CALL PR_CANCEL_INVOICE(88, V_CODE, V_MESSAGE, V_LOG);
-- 	RAISE NOTICE 'CODE: %', V_CODE;
--     RAISE NOTICE 'MESSAGE: %', V_MESSAGE;
-- 	RAISE NOTICE 'LOG: %', V_LOG;
-- END $$;

DROP PROCEDURE IF EXISTS PR_APPROVED_INVOICE;

CREATE OR REPLACE PROCEDURE PR_APPROVED_INVOICE(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN

	IF NOT EXISTS (SELECT DH.NUMINT FROM TBL_DOCUMENT_HEADER DH WHERE DH.IDCOMPANY = IN_IDCOMPANY AND DH.NUMINT = IN_NUMINT ) THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'Record with ID [ ' || IN_NUMINT::VARCHAR || ' ] does not exists';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
	ELSE		
		UPDATE TBL_DOCUMENT_HEADER
		SET
			SITCOMDOC = 2,
			UPDATEBY = IN_CODUSER,
			UPDATEAT = NOW()
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = IN_NUMINT;
			
		CALL PR_CREATE_DOCUMENT_TRANSACTION(IN_IDCOMPANY, IN_CODUSER, IN_NUMINT, 'APPROVED DOCUMENT', '', V_CODE, V_MESSAGE, V_LOG);
		
		IF V_CODE <> 1 THEN
			OUT_CODE := V_CODE;
			OUT_MESSAGE := V_MESSAGE;
			OUT_LOG := V_LOG;
			RETURN;
		END IF;

		OUT_CODE := 1;
		OUT_MESSAGE := 'SUCCESSFUL APPROVAL';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
		
	END IF;	
	
EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
END $$;

DROP PROCEDURE IF EXISTS PR_ONACCOUNT_INVOICE;

CREATE OR REPLACE PROCEDURE PR_ONACCOUNT_INVOICE(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_CODE INTEGER;
	V_MESSAGE VARCHAR(1000);
	V_LOG VARCHAR(1000);
BEGIN

	IF NOT EXISTS (SELECT DH.NUMINT FROM TBL_DOCUMENT_HEADER DH WHERE DH.IDCOMPANY = IN_IDCOMPANY AND DH.NUMINT = IN_NUMINT ) THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'Record with ID [ ' || IN_NUMINT::VARCHAR || ' ] does not exists';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
	ELSE		
		UPDATE TBL_DOCUMENT_HEADER
		SET
			SITCOMDOC = 3,
			UPDATEBY = IN_CODUSER,
			UPDATEAT = NOW()
		WHERE
			IDCOMPANY = IN_IDCOMPANY AND
			NUMINT = IN_NUMINT;

		CALL PR_CREATE_DOCUMENT_TRANSACTION(IN_IDCOMPANY, IN_CODUSER, IN_NUMINT, 'ON ACCOUNT DOCUMENT', '', V_CODE, V_MESSAGE, V_LOG);
		
		IF V_CODE <> 1 THEN
			OUT_CODE := V_CODE;
			OUT_MESSAGE := V_MESSAGE;
			OUT_LOG := V_LOG;
			RETURN;
		END IF;
			
		OUT_CODE := 1;
		OUT_MESSAGE := 'SUCCESSFUL APPROVAL';
		OUT_LOG := OUT_MESSAGE;
		RETURN;
		
	END IF;	
	
EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
END $$;

DROP PROCEDURE IF EXISTS PR_SENT_DOCUMENT_KARDEX;

CREATE OR REPLACE PROCEDURE PR_SENT_DOCUMENT_KARDEX(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_NUMINT IN BIGINT,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_GEN_KARDEX VARCHAR(1000);
    V_SEQUENCE_EXISTS BOOLEAN;
BEGIN

	V_GEN_KARDEX := UPPER('GEN_' || IN_IDCOMPANY || '_KARDEX');
	SELECT EXISTS (SELECT 1 FROM pg_class WHERE UPPER(relname) = V_GEN_KARDEX) INTO V_SEQUENCE_EXISTS;

    IF NOT sequence_exists THEN
        RAISE EXCEPTION 'THE SEQUENCE % DOES NOT EXIST', V_GEN_KARDEX;
    END IF;

	DELETE FROM DOCUMENT_KARDEX
	WHERE
		IDCOMPANY = IN_IDCOMPANY AND
		NUMINT = IN_NUMINT;

	INSERT INTO DOCUMENT_KARDEX
	SELECT 
		DH.IDCOMPANY,
		nextval(V_GEN_KARDEX) AS LOCALI,
		DH.NUMINT,
		DD.NUMITE,
		DD.TYPINV,
		DD.CODART,
		DD.ETIQUETA,
		DD.QUANTITY,
		DD.PRICE,
		DH.TYPCOMDOC,
		DH.INOUT,
		DH.REACOMDOC,
		DD.CODBRANCH,
		DD.ORIWAREHOUSE,
		DD.DESWAREHOUSE,
		DH.REGISTDATE,
		EXTRACT(YEAR FROM DH.REGISTDATE) AS YEAR,
		EXTRACT(MONTH FROM DH.REGISTDATE) AS MONTH,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPLISTPRICE
		ELSE
			DD.IMPLISTPRICE * EXCHANGERATE01
		END AS IMPLISTPRICE01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPLISTPRICE * EXCHANGERATE02
		ELSE
			DD.IMPLISTPRICE
		END AS IMPLISTPRICE02,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPDESCTOTAL
		ELSE
			DD.IMPDESCTOTAL * EXCHANGERATE01
		END AS IMPDESCTOTAL01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPDESCTOTAL * EXCHANGERATE02
		ELSE
			DD.IMPDESCTOTAL
		END AS IMPDESCTOTAL02,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPSALEPRICE
		ELSE
			DD.IMPSALEPRICE * EXCHANGERATE01
		END AS IMPSALEPRICE01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPSALEPRICE * EXCHANGERATE02
		ELSE
			DD.IMPSALEPRICE
		END AS IMPSALEPRICE02,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTRIBTOTAL
		ELSE
			DD.IMPTRIBTOTAL * EXCHANGERATE01
		END AS IMPTRIBTOTAL01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTRIBTOTAL * EXCHANGERATE02
		ELSE
			DD.IMPTRIBTOTAL
		END AS IMPTRIBTOTAL02,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTOTAL
		ELSE
			DD.IMPTOTAL * EXCHANGERATE01
		END AS IMPTOTAL01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTOTAL * EXCHANGERATE02
		ELSE
			DD.IMPTOTAL
		END AS IMPTOTAL02,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTOTAL
		ELSE
			DD.IMPTOTAL * DH.EXCHANGERATE01
		END AS COSRAWMATERIAL01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTOTAL * DH.EXCHANGERATE02
		ELSE
			DD.IMPTOTAL
		END AS COSRAWMATERIAL02,
		0 AS COSMANUFACTURING01,
		0 AS COSMANUFACTURING02,
		0 AS COSLABOUR01,
		0 AS COSLABOUR02,
		0 AS COSTRANSPORT01,
		0 AS COSTRANSPORT02,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTOTAL
		ELSE
			DD.IMPTOTAL * DH.EXCHANGERATE01
		END AS COSTOTAL01,
		CASE WHEN DH.CODCUR = C.CODCUR THEN
			DD.IMPTOTAL * DH.EXCHANGERATE02
		ELSE
			DD.IMPTOTAL
		END AS COSTOTAL02,
		'Y' AS STATUS,
		IN_CODUSER AS CREATEBY,
		IN_CODUSER AS UPDATEBY,
		CURRENT_TIMESTAMP AS CREATEAT,
		CURRENT_TIMESTAMP AS UPDATEAT
	FROM TBL_DOCUMENT_HEADER DH
	INNER JOIN TBL_DOCUMENT_DETAIL DD ON DD.IDCOMPANY = DH.IDCOMPANY AND DD.NUMINT = DH.NUMINT
	INNER JOIN TBL_CURRENCY C ON C.IDCOMPANY = DH.IDCOMPANY AND C.DEFAUL = 'Y'
	WHERE
		DH.IDCOMPANY = IN_IDCOMPANY AND
		DH.NUMINT = IN_NUMINT;

	OUT_CODE := 0;
	OUT_MESSAGE := 'THE DOCUMENT [ ' || V_NUMINT::TEXT || ' ] HAS BEEN SENT TO THE KARDEX';
	OUT_LOG := OUT_MESSAGE;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
	RETURN;
END $$;