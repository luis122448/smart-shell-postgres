SET search_path TO smart_shell;

-- SELECT current_schema();

-- PROCEDURE AND FUNCTION

CREATE TABLE TBL_ARTICLE_COST(
    IDCOMPANY INTEGER,
	TYPINV INTEGER,
	CODART VARCHAR(50),
	YEAR INTEGER,
	MONTH INTEGER,
	-- TOTAL
	STOCK NUMERIC(24,4),
	AVGCOST01 NUMERIC(24,4),
	AVGCOST02 NUMERIC(24,4),
	-- STOCK
	STOCKBEGIN NUMERIC(24,4),
	STOCKIN NUMERIC(24,4),
	STOCKOUT NUMERIC(24,4),
	STOCKEND NUMERIC(24,4),
	-- COST
	COST01BEGIN NUMERIC(24,4),
	COST01IN NUMERIC(24,4),
	COST01OUT NUMERIC(24,4),
	COST01END NUMERIC(24,4),
	COST02BEGIN NUMERIC(24,4),
	COST02IN NUMERIC(24,4),
	COST02OUT NUMERIC(24,4),
	COST02END NUMERIC(24,4),
	STATUS VARCHAR(1) DEFAULT 'Y',
	CREATEBY VARCHAR(10) DEFAULT 'ADMIN',
	UPDATEBY VARCHAR(10) DEFAULT 'ADMIN',
	CREATEAT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	UPDATEAT TIMESTAMP DEFAULT CURRENT_TIMESTAMP	
);

ALTER TABLE TBL_ARTICLE_COST
	ADD CONSTRAINT PK_ARTICLE_COST PRIMARY KEY (IDCOMPANY,TYPINV,CODART,YEAR,MONTH);

CREATE TABLE TBL_ARTICLE_WAREHOUSE_COST(
	IDCOMPANY INTEGER,
	TYPINV INTEGER,
	CODART VARCHAR(50),
	YEAR INTEGER,
	MONTH INTEGER,
	CODBRANCH INTEGER,
	CODWAREHOUSE INTEGER,
	STOCK NUMERIC(24,4),
	AVGCOST01 NUMERIC(24,4),
	AVGCOST02 NUMERIC(24,4),
	-- STOCK
	STOCKBEGIN NUMERIC(24,4),
	STOCKIN NUMERIC(24,4),
	STOCKOUT NUMERIC(24,4),
	STOCKEND NUMERIC(24,4),
	-- COST
	COST01BEGIN NUMERIC(24,4),
	COST01IN NUMERIC(24,4),
	COST01OUT NUMERIC(24,4),
	COST01END NUMERIC(24,4),
	COST02BEGIN NUMERIC(24,4),
	COST02IN NUMERIC(24,4),
	COST02OUT NUMERIC(24,4),
	COST02END NUMERIC(24,4),
	STATUS VARCHAR(1) DEFAULT 'Y',
	CREATEBY VARCHAR(10) DEFAULT 'ADMIN',
	UPDATEBY VARCHAR(10) DEFAULT 'ADMIN',
	CREATEAT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	UPDATEAT TIMESTAMP DEFAULT CURRENT_TIMESTAMP	
);

ALTER TABLE TBL_ARTICLE_WAREHOUSE_COST
	ADD CONSTRAINT PK_ARTICLE_WAREHOUSE_COST PRIMARY KEY (IDCOMPANY,TYPINV,CODART,YEAR,MONTH,CODBRANCH,CODWAREHOUSE);

DROP PROCEDURE IF EXISTS PR_RECALCULATE_TOTAL_COST;

CREATE OR REPLACE PROCEDURE PR_RECALCULATE_TOTAL_COST(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_TYPINV IN INTEGER,
	IN_YEAR IN INTEGER,
	IN_MONTH IN INTEGER,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_INDEX INTEGER := 1;
BEGIN

	-- DELETE ARTICLE COST
	DELETE FROM TBL_ARTICLE_COST
	WHERE IDCOMPANY = IN_IDCOMPANY
	AND YEAR = IN_YEAR
	AND MONTH = IN_MONTH
	AND TYPINV = IN_TYPINV;

	-- DELETE ARTICLE WAREHOUSE COST
	DELETE FROM TBL_ARTICLE_WAREHOUSE_COST
	WHERE IDCOMPANY = IN_IDCOMPANY
	AND YEAR = IN_YEAR
	AND MONTH = IN_MONTH
	AND TYPINV = IN_TYPINV;

	-- INSERT ARTICLE COST ( MOVEMENT IN DOCUMENT KARDEX )
	INSERT INTO TBL_ARTICLE_COST
	SELECT
		DK.IDCOMPANY,
		DK.TYPINV,
		DK.CODART,
		DK.YEAR,
		DK.MONTH,
		-- TOTAL
		SUM(0) AS STOCK,
		SUM(0) AS AVGCOST01,
		SUM(0) AS AVGCOST02,
		-- STOCK
		AC.STOCKEND AS STOCKBEGIN,
		SUM(CASE WHEN DK.INOUT = 1 THEN DK.QUANTITY ELSE 0 END) AS STOCKIN,
		SUM(CASE WHEN DK.INOUT = 2 THEN 0 ELSE DK.QUANTITY END) AS STOCKOUT,
		SUM(0) AS STOCKEND,
		-- COST
		AC.COST01END AS COST01BEGIN,
		SUM(CASE WHEN DK.INOUT = 1 THEN DK.COSTOTAL01 ELSE 0 END) AS COST01IN,
		SUM(CASE WHEN DK.INOUT = 2 THEN 0 ELSE DK.COSTOTAL01 END) AS COST01OUT,
		SUM(0) AS COST01END,
		AC.COST02END AS COST02BEGIN,
		SUM(CASE WHEN DK.INOUT = 1 THEN DK.COSTOTAL02 ELSE 0 END) AS COST02IN,
		SUM(CASE WHEN DK.INOUT = 2 THEN 0 ELSE DK.COSTOTAL02 END) AS COST02OUT,
		SUM(0) AS COST02END,
		'Y' AS STATUS,
		IN_CODUSER AS CREATEBY,
		IN_CODUSER AS UPDATEBY,
		CURRENT_TIMESTAMP AS CREATEAT,
		CURRENT_TIMESTAMP AS UPDATEAT
	FROM TBL_DOCUMENT_KARDEX DK
	LEFT OUTER JOIN TBL_ARTICLE_COST AC ON AC.IDCOMPANY = DK.IDCOMPANY AND AC.TYPINV = DK.TYPINV AND AC.CODART = DK.CODART AND AC.YEAR = DK.YEAR AND AC.MONTH = DK.MONTH - 1
	WHERE DK.IDCOMPANY = IN_IDCOMPANY
	AND DK.YEAR = IN_YEAR
	AND DK.MONTH = IN_MONTH
	AND DK.TYPINV = IN_TYPINV
	AND DK.STATUS = 'Y'
	GROUP BY DK.IDCOMPANY, DK.TYPINV, DK.CODART, DK.YEAR, DK.MONTH, 'Y', IN_CODUSER, CURRENT_TIMESTAMP;

	-- CALCULATE COST
	UPDATE TBL_ARTICLE_COST
	SET 
		STOCK = STOCKBEGIN + STOCKIN - STOCKOUT,
		AVGCOST01 = CASE WHEN STOCKEND = 0 THEN 0 ELSE COST01END / STOCKEND END,
		AVGCOST02 = CASE WHEN STOCKEND = 0 THEN 0 ELSE COST02END / STOCKEND END,
		STOCKEND = STOCKBEGIN + STOCKIN - STOCKOUT,
		COST01END = COST01BEGIN + COST01IN - COST01OUT,
		COST02END = COST02BEGIN + COST02IN - COST02OUT
	WHERE IDCOMPANY = IN_IDCOMPANY
	AND YEAR = IN_YEAR
	AND MONTH = IN_MONTH
	AND TYPINV = IN_TYPINV
	AND STATUS = 'Y';

	-- INSERT ARTICLE COST ( MOVEMENT IN NOT DOCUMENT KARDEX )
	INSERT INTO TBL_ARTICLE_COST
	SELECT
		DK.IDCOMPANY,
		DK.TYPINV,
		DK.CODART,
		DK.YEAR,
		DK.MONTH,
		-- TOTAL
		AC.STOCK AS STOCK,
		AC.AVGCOST01 AS AVGCOST01,
		AC.AVGCOST02 AS AVGCOST02,
		-- STOCK
		AC.STOCKEND AS STOCKBEGIN,
		0 AS STOCKIN,
		0 AS STOCKOUT,
		AC.STOCKEND AS STOCKEND,
		-- COST
		AC.COST01END AS COST01BEGIN,
		0 AS COST01IN,
		0 AS COST01OUT,
		AC.COST01END AS COST01END,
		AC.COST02END AS COST02BEGIN,
		0 AS COST02IN,
		0 AS COST02OUT,
		AC.COST02END AS COST02END,
		'Y' AS STATUS,
		IN_CODUSER AS CREATEBY,
		IN_CODUSER AS UPDATEBY,
		CURRENT_TIMESTAMP AS CREATEAT,
		CURRENT_TIMESTAMP AS UPDATEAT
	FROM TBL_ARTICLE_COST AC
	WHERE AC.IDCOMPANY = IN_IDCOMPANY
	AND AC.YEAR = IN_YEAR
	AND AC.MONTH = IN_MONTH - 1
	AND AC.TYPINV = IN_TYPINV
	AND NOT EXISTS(
		SELECT 1
		FROM DOCUMENT_KARDEX DK
		WHERE DK.IDCOMPANY = AC.IDCOMPANY
		AND DK.YEAR = AC.YEAR
		AND DK.MONTH = AC.MONTH
		AND DK.TYPINV = AC.TYPINV
		AND DK.CODART = AC.CODART
		AND DK.STATUS = 'Y'
	);

	-- INSERT ARTICLE WAREHOUSE COST ( MOVEMENT IN DOCUMENT KARDEX )
	INSERT INTO TBL_ARTICLE_WAREHOUSE_COST
	SELECT
		DK.IDCOMPANY,
		DK.TYPINV,
		DK.CODART,
		DK.YEAR,
		DK.MONTH,
		DK.CODBRANCH,
		DK.ORIWAREHOUSE,
		-- TOTAL
		SUM(0) AS STOCK,
		SUM(0) AS AVGCOST01,
		SUM(0) AS AVGCOST02,
		-- STOCK
		AC.STOCKEND AS STOCKBEGIN,
		SUM(CASE WHEN DK.INOUT = 1 THEN DK.QUANTITY ELSE 0 END) AS STOCKIN,
		SUM(CASE WHEN DK.INOUT = 2 THEN 0 ELSE DK.QUANTITY END) AS STOCKOUT,
		SUM(0) AS STOCKEND,
		-- COST
		AC.COST01END AS COST01BEGIN,
		SUM(CASE WHEN DK.INOUT = 1 THEN DK.COSTOTAL01 ELSE 0 END) AS COST01IN,
		SUM(CASE WHEN DK.INOUT = 2 THEN 0 ELSE DK.COSTOTAL01 END) AS COST01OUT,
		SUM(0) AS COST01END,
		AC.COST02END AS COST02BEGIN,
		SUM(CASE WHEN DK.INOUT = 1 THEN DK.COSTOTAL02 ELSE 0 END) AS COST02IN,
		SUM(CASE WHEN DK.INOUT = 2 THEN 0 ELSE DK.COSTOTAL02 END) AS COST02OUT,
		SUM(0) AS COST02END,
		'Y' AS STATUS,
		IN_CODUSER AS CREATEBY,
		IN_CODUSER AS UPDATEBY,
		CURRENT_TIMESTAMP AS CREATEAT,
		CURRENT_TIMESTAMP AS UPDATEAT
	FROM TBL_DOCUMENT_KARDEX DK
	LEFT OUTER JOIN TBL_ARTICLE_WAREHOUSE_COST AC ON AC.IDCOMPANY = DK.IDCOMPANY AND AC.TYPINV = DK.TYPINV AND AC.CODART = DK.CODART AND AC.YEAR = DK.YEAR AND AC.MONTH = DK.MONTH - 1 AND AC.CODBRANCH = DK.CODBRANCH AND AC.CODWAREHOUSE = DK.ORIWAREHOUSE
	WHERE DK.IDCOMPANY = IN_IDCOMPANY
	AND DK.YEAR = IN_YEAR
	AND DK.MONTH = IN_MONTH
	AND DK.TYPINV = IN_TYPINV
	AND DK.STATUS = 'Y'
	GROUP BY DK.IDCOMPANY, DK.TYPINV, DK.CODART, DK.YEAR, DK.MONTH, DK.CODBRANCH, DK.ORIWAREHOUSE, 'Y', IN_CODUSER, CURRENT_TIMESTAMP;

	-- CALCULATE COST
	UPDATE TBL_ARTICLE_WAREHOUSE_COST
	SET 
		STOCK = STOCKBEGIN + STOCKIN - STOCKOUT,
		AVGCOST01 = CASE WHEN STOCKEND = 0 THEN 0 ELSE COST01END / STOCKEND END,
		AVGCOST02 = CASE WHEN STOCKEND = 0 THEN 0 ELSE COST02END / STOCKEND END,
		STOCKEND = STOCKBEGIN + STOCKIN - STOCKOUT,
		COST01END = COST01BEGIN + COST01IN - COST01OUT,
		COST02END = COST02BEGIN + COST02IN - COST02OUT
	WHERE IDCOMPANY = IN_IDCOMPANY
	AND YEAR = IN_YEAR
	AND MONTH = IN_MONTH
	AND TYPINV = IN_TYPINV
	AND STATUS = 'Y';

	-- INSERT ARTICLE WAREHOUSE COST ( MOVEMENT IN NOT DOCUMENT KARDEX )
	INSERT INTO TBL_ARTICLE_WAREHOUSE_COST
	SELECT
		DK.IDCOMPANY,
		DK.TYPINV,
		DK.CODART,
		DK.YEAR,
		DK.MONTH,
		DK.CODBRANCH,
		DK.ORIWAREHOUSE,
		-- TOTAL
		AC.STOCK AS STOCK,
		AC.AVGCOST01 AS AVGCOST01,
		AC.AVGCOST02 AS AVGCOST02,
		-- STOCK
		AC.STOCKEND AS STOCKBEGIN,
		0 AS STOCKIN,
		0 AS STOCKOUT,
		AC.STOCKEND AS STOCKEND,
		-- COST
		AC.COST01END AS COST01BEGIN,
		0 AS COST01IN,
		0 AS COST01OUT,
		AC.COST01END AS COST01END,
		AC.COST02END AS COST02BEGIN,
		0 AS COST02IN,
		0 AS COST02OUT,
		AC.COST02END AS COST02END,
		'Y' AS STATUS,
		IN_CODUSER AS CREATEBY,
		IN_CODUSER AS UPDATEBY,
		CURRENT_TIMESTAMP AS CREATEAT,
		CURRENT_TIMESTAMP AS UPDATEAT
	FROM TBL_ARTICLE_WAREHOUSE_COST AC
	WHERE AC.IDCOMPANY = IN_IDCOMPANY
	AND AC.YEAR = IN_YEAR
	AND AC.MONTH = IN_MONTH - 1
	AND AC.TYPINV = IN_TYPINV
	AND NOT EXISTS(
		SELECT 1
		FROM DOCUMENT_KARDEX DK
		WHERE DK.IDCOMPANY = AC.IDCOMPANY
		AND DK.YEAR = AC.YEAR
		AND DK.MONTH = AC.MONTH
		AND DK.TYPINV = AC.TYPINV
		AND DK.CODART = AC.CODART
		AND DK.CODBRANCH = AC.CODBRANCH
		AND DK.ORIWAREHOUSE = AC.CODWAREHOUSE
		AND DK.STATUS = 'Y'
	);

	OUT_CODE := 1;
	OUT_MESSAGE := 'THE DOCUMENT [ ' || IN_NUMINT::TEXT || ' ] IS TRANSACTION';
	OUT_LOG := OUT_MESSAGE;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
		RETURN;
END $$;

DROP PROCEDURE IF EXISTS PR_WEIGHTED_AVERAGE_COST;

CREATE OR REPLACE PROCEDURE PR_WEIGHTED_AVERAGE_COST(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_TYPINV IN INTEGER,
	IN_YEAR IN INTEGER,
	IN_MONTH IN INTEGER,
	OUT_CODE OUT INTEGER,
	OUT_MESSAGE OUT VARCHAR,
	OUT_LOG OUT VARCHAR
)
LANGUAGE PLPGSQL
AS $$
DECLARE
	V_INDEX INTEGER := 1;
	REC_ARTICLE_COST TBL_ARTICLE_COST%ROWTYPE;
	I RECORD;
BEGIN

	FOR I IN(
		SELECT
			DK.IDCOMPANY,
			DK.LOCALI,
			DK.TYPINV,
			DK.CODART,
			DK.YEAR,
			DK.MONTH,
			DK.INOUT,
			DK.QUANTITY,
			COALESCE(DK.COSTOTAL01,0) AS COSTOTAL01,
			COALESCE(DK.COSTOTAL02,0) AS COSTOTAL02,
			DK.TYPMETHODCOST,
			AC.STOCKEND AS STOCKBEGIN,
			AC.COST01END AS COST01BEGIN,
			AC.COST02END AS COST02BEGIN
		FROM 
			TBL_DOCUMENT_KARDEX DK
		LEFT OUTER JOIN TBL_ARTICLE_COST AC ON AC.IDCOMPANY = DK.IDCOMPANY AND AC.TYPINV = DK.TYPINV AND AC.CODART = DK.CODART AND AC.YEAR = DK.YEAR AND AC.MONTH = DK.MONTH - 1
		WHERE 
			DK.IDCOMPANY = IN_IDCOMPANY
			AND DK.YEAR = IN_YEAR
			AND DK.MONTH = IN_MONTH
			AND DK.TYPINV = IN_TYPINV
			AND DK.STATUS = 'Y'
		ORDER BY
			DK.TYPINV ASC,
			DK.CODART ASC,
			DK.REGISTDATE ASC,
			DK.INOUT ASC
	) LOOP 

		IF V_INDEX = 1 THEN
			REC_ARTICLE_COST.STOCKEND := I.STOCKBEGIN;
			REC_ARTICLE_COST.COST01END := I.COST01BEGIN;
			REC_ARTICLE_COST.COST02END := I.COST02BEGIN;
		END IF;

		IF I.TYPMETHODCOST = 0 THEN
			IF I.INOUT = 1 THEN
				REC_ARTICLE_COST.STOCKEND := REC_ARTICLE_COST.STOCKEND + I.QUANTITY;
				REC_ARTICLE_COST.COST01END := REC_ARTICLE_COST.COST01END + I.COSTOTAL01;
				REC_ARTICLE_COST.COST02END := REC_ARTICLE_COST.COST02END + I.COSTOTAL02;
			ELSE
				REC_ARTICLE_COST.STOCKEND := REC_ARTICLE_COST.STOCKEND - I.QUANTITY;
				REC_ARTICLE_COST.COST01END := REC_ARTICLE_COST.COST01END - I.COSTOTAL01;
				REC_ARTICLE_COST.COST02END := REC_ARTICLE_COST.COST02END - I.COSTOTAL02;
			END IF;
		ELSE

			IF I.INOUT = 2 THEN
				REC_ARTICLE_COST.STOCKEND := REC_ARTICLE_COST.STOCKEND + I.QUANTITY;
				REC_ARTICLE_COST.COST01END := REC_ARTICLE_COST.COST01END + (CASE WHEN REC_ARTICLE_COST.STOCKEND = 0 THEN 0 ELSE ((REC_ARTICLE_COST.COST01END * I.QUANTITY)/REC_ARTICLE_COST.STOCKEND) END);
				REC_ARTICLE_COST.COST02END := REC_ARTICLE_COST.COST02END + (CASE WHEN REC_ARTICLE_COST.STOCKEND = 0 THEN 0 ELSE ((REC_ARTICLE_COST.COST02END * I.QUANTITY)/REC_ARTICLE_COST.STOCKEND) END);
			ELSE
				REC_ARTICLE_COST.STOCKEND := REC_ARTICLE_COST.STOCKEND - I.QUANTITY;
				REC_ARTICLE_COST.COST01END := REC_ARTICLE_COST.COST01END - (CASE WHEN REC_ARTICLE_COST.STOCKEND = 0 THEN 0 ELSE ((REC_ARTICLE_COST.COST01END * I.QUANTITY)/REC_ARTICLE_COST.STOCKEND) END);
				REC_ARTICLE_COST.COST02END := REC_ARTICLE_COST.COST02END - (CASE WHEN REC_ARTICLE_COST.STOCKEND = 0 THEN 0 ELSE ((REC_ARTICLE_COST.COST02END * I.QUANTITY)/REC_ARTICLE_COST.STOCKEND) END);
			END IF;

			UPDATE TBL_DOCUMENT_KARDEX
			SET
				COSTOTAL01 = REC_ARTICLE_COST.COST01END,
				COSTOTAL02 = REC_ARTICLE_COST.COST02END
			WHERE IDCOMPANY = I.IDCOMPANY
			AND LOCALI = I.LOCALI
			AND TYPMETHODCOST = 1; -- REDUNDANCY

		END IF;

	END LOOP;

	OUT_CODE := 1;
	OUT_MESSAGE := 'THE DOCUMENT [ ' || IN_NUMINT::TEXT || ' ] IS TRANSACTION';
	OUT_LOG := OUT_MESSAGE;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		OUT_CODE := -2;
		OUT_MESSAGE := 'AN UNKNOWN ERROR HAS OCCURRED';
		OUT_LOG := 'ERROR ( ' || SQLSTATE || ' ) : ' || SQLERRM;
		RETURN;
END $$;

DROP FUNCTION IF EXISTS FN_KARDEX_VALUED;

DROP TYPE IF EXISTS REC_KARDEX_VALUED;

CREATE TYPE REC_KARDEX_VALUED AS (
	-- PRINT
	FORMAT VARCHAR(250),
	-- COMPANY
	COMDESTYPIDEDOC VARCHAR(250),
	COMNROIDEDOC VARCHAR(100), 
	COMNAM VARCHAR(250),
	COMADDRES VARCHAR(250),
	COMPOSCOD VARCHAR(20), 
	COMGLOSS BYTEA,
	-- HEADER
	NUMINT BIGINT,
	NUMDOC BIGINT,
	SERIE  VARCHAR(5),
	DESDOCCOM VARCHAR(250),
	DESSITCOMDOC VARCHAR(250),
	REGISTDATE DATE,
	DESINOUT VARCHAR(250),
	DESREACOMDOC VARCHAR(250),
	CODBUSPAR VARCHAR(50),
	DESTYPIDEDOC VARCHAR(250),
	NROIDEDOC VARCHAR(100),
	BUSNAM VARCHAR(250),
	ADDRES VARCHAR(250),
	POSCOD VARCHAR(20),
	DESPLAISS VARCHAR(250),
	DESORIWAREHOUSE VARCHAR(250),
	DESDESWAREHOUSE VARCHAR(250),
	-- CURRENCY
	CODCUR VARCHAR(5),
	CURSYMBOL VARCHAR(5),
	EXCHANGERATE NUMERIC(8,4),
	DESSEL VARCHAR(250),
	DESPAYCON VARCHAR(250),
	-- DETAIL
	NUMITE BIGINT,
    TYPINV INTEGER,
	DESTYPINV VARCHAR(250),
    CODART VARCHAR(50),
    DESART VARCHAR(250),
	-- KARDEX
	LOCALI BIGINT,
	YEAR INTEGER,
	MONTH INTEGER,
	INOUT INTEGER,
	-- STOCK
	STOCKBEGIN NUMERIC(24,4),
	STOCKIN NUMERIC(24,4),
	STOCKOUT NUMERIC(24,4),
	STOCKEND NUMERIC(24,4),
	-- COST
	COSTBEGIN NUMERIC(24,4),
	COSTIN NUMERIC(24,4),
	COSTOUT NUMERIC(24,4),
	COSTEND NUMERIC(24,4),
	COSTAVGBEGIN NUMERIC(24,4),
	COSTAVGIN NUMERIC(24,4),
	COSTAVGOUT NUMERIC(24,4),
	COSTAVGEND NUMERIC(24,4)
);

CREATE OR REPLACE FUNCTION FN_KARDEX_VALUED(
	IN_IDCOMPANY IN INTEGER,
	IN_CODUSER IN VARCHAR,
	IN_CODCUR IN VARCHAR,
	IN_TYPINV IN INTEGER,
	IN_CODART IN VARCHAR,
	IN_YEAR IN INTEGER,
	IN_MONTH IN INTEGER,
	IN_CODBRANCH IN INTEGER,
	IN_CODWAREHOUSE IN INTEGER
)
RETURNS SETOF REC_KARDEX_VALUED AS
$BODY$
DECLARE
	REC REC_KARDEX_VALUED%ROWTYPE;
	V_INDEX INTEGER := 1;
	I RECORD;
BEGIN
	FOR I IN(
		SELECT
			'kardex-valued-a4-format' AS FORMAT,
			-- COMPANY
			TID1.DESCRI AS COMDESTYPIDEDOC,
			CI.COMPANY AS COMNROIDEDOC,
			CI.APPELLATION AS COMNAM,
			CI.ADDRES AS COMADDRES,
			CI.POSCOD AS COMPOSCOD,
			CI.GLOSS AS COMGLOSS,
			-- HEADER
			DH.NUMINT,
			DH.NUMDOC,
			DH.SERIE,
			TDC.DESCRI AS DESDOCCOM,
			SDC.DESCRI AS DESSITCOMDOC,
			DH.REGISTDATE,
			CAST(CASE WHEN DH.INOUT = 1 THEN
				'Ingreso'
			ELSE
				'Salida'		
			END AS VARCHAR(250)) AS DESINOUT,
			MDC.DESCRI AS DESREACOMDOC,
			DH.CODBUSPAR,
			TID2.DESCRI AS DESTYPCOMDOC,
			BP.NROIDEDOC, 
			DH.BUSNAM,
			DH.ADDRES,
			DH.POSCOD,
			CAST(CASE WHEN DH.CODPLAISS = 1 THEN
				'Punt Venta'
			ELSE
				'ND'
			END AS VARCHAR(250)) AS DESPLAISS,
			WO.DESCRI AS DESORIWAREHOUSE,
			WD.DESCRI AS DESDESWAREHOUSE,
			DH.CODCUR,
			C.SYMBOL AS CURSYMBOL,
			-- DETAILS
			DD.NUMITE,
			DD.TYPINV,
			TI.DESCRI AS DESTYPINV,
			DD.CODART,
			A.DESCRI AS DESART,
			DK.LOCALI,
			DK.YEAR,
			DK.MONTH,
			DK.INOUT,
			DK.QUANTITY,
			COALESCE(DK.COSTOTAL01,0) AS COSTOTAL01,
			COALESCE(DK.COSTOTAL02,0) AS COSTOTAL02,
			AC.STOCKBEGIN,
			AC.COST01BEGIN,
			AC.COST02BEGIN,
			AC.STOCKEND,
			AC.COST01END,
			AC.COST02END
		FROM 
			TBL_DOCUMENT_KARDEX DK
		LEFT OUTER JOIN TBL_ARTICLE_COST AC ON AC.IDCOMPANY = DK.IDCOMPANY AND AC.TYPINV = DK.TYPINV AND AC.CODART = DK.CODART AND AC.YEAR = DK.YEAR AND AC.MONTH = DK.MONTH
		LEFT OUTER JOIN TBL_DOCUMENT_HEADER DH ON DH.IDCOMPANY = DK.IDCOMPANY AND DH.NUMINT = DK.NUMINT
		LEFT OUTER JOIN TBL_DOCUMENT_DETAIL DD ON DD.IDCOMPANY = DK.IDCOMPANY AND DD.NUMINT = DK.NUMINT AND DD.NUMITE = DK.NUMITE
		LEFT OUTER JOIN TBL_CURRENCY C ON C.IDCOMPANY = DH.IDCOMPANY AND C.DEFAUL = 'Y'
		WHERE	
			DK.IDCOMPANY = IN_IDCOMPANY
			AND DK.YEAR = IN_YEAR
			AND DK.MONTH = IN_MONTH
			AND DK.TYPINV = IN_TYPINV
			AND ( IN_CODART IS NULL OR DK.CODART = IN_CODART )
			AND DK.STATUS = 'Y'
		ORDER BY
			DK.TYPINV ASC,
			DK.CODART ASC,
			DK.REGISTDATE ASC,
			DK.INOUT ASC
	) LOOP

		-- FORMAT
		REC.FORMAT := I.FORMAT;

		-- COMPANY
		REC.COMDESTYPIDEDOC := I.COMDESTYPIDEDOC;
		REC.COMNROIDEDOC := I.COMNROIDEDOC; 
		REC.COMNAM := I.COMNAM;
		REC.COMADDRES := I.COMADDRES;
		REC.COMPOSCOD := I.COMPOSCOD; 
		REC.COMGLOSS := I.COMGLOSS;

		-- HEADER
		REC.NUMINT := I.NUMINT;
		REC.NUMDOC := I.NUMDOC;		
		REC.SERIE := I.SERIE;
		REC.DESDOCCOM := I.DESDOCCOM;
		REC.DESSITCOMDOC := I.DESSITCOMDOC;
		REC.REGISTDATE := I.REGISTDATE;
		REC.DESINOUT := I.DESINOUT;
		REC.DESREACOMDOC := I.DESREACOMDOC;
		REC.CODBUSPAR := I.CODBUSPAR;
		REC.DESTYPIDEDOC := I.DESTYPIDEDOC;
		REC.NROIDEDOC := I.NROIDEDOC;
		REC.BUSNAM := I.BUSNAM;
		REC.ADDRES := I.ADDRES;
		REC.POSCOD := I.POSCOD;
		REC.DESPLAISS := I.DESPLAISS;
		REC.DESORIWAREHOUSE := I.DESORIWAREHOUSE;
		REC.DESDESWAREHOUSE := I.DESDESWAREHOUSE;

		-- DETAIL
		REC.NUMITE := I.NUMITE;
		REC.TYPINV := I.TYPINV;
		REC.DESTYPINV := I.DESTYPINV;
		REC.CODART := I.CODART;
		REC.DESART := I.DESART;

		-- KARDEX
		REC.LOCALI := I.LOCALI;
		REC.YEAR := I.YEAR;
		REC.MONTH := I.MONTH;
		REC.INOUT := I.INOUT;

		IF V_INDEX = 1 OR REC.CODART <> I.CODART THEN
			REC.STOCKBEGIN := I.STOCKBEGIN;
			IF IN_CODCUR = I.CODCUR THEN
				REC.COSTBEGIN := I.COST01BEGIN;
			ELSE
				REC.COSTBEGIN := I.COST02BEGIN;
			END IF;
		ELSE
			REC.STOCKBEGIN := REC.STOCKEND;
			IF IN_CODCUR = I.CODCUR THEN
				REC.COSTBEGIN := REC.COST01END;
			ELSE
				REC.COSTBEGIN := REC.COST02END;
			END IF;
		END IF;

		REC.STOCKIN := CASE WHEN I.INOUT = 1 THEN I.QUANTITY ELSE 0 END;
		REC.STOCKOUT := CASE WHEN I.INOUT = 2 THEN I.QUANTITY ELSE 0 END;
		REC.STOCKEND := REC.STOCKBEGIN + REC.STOCKIN - REC.STOCKOUT;

		IF IN_CODCUR = I.CODCUR THEN
			REC.COSTIN := CASE WHEN I.INOUT = 1 THEN I.COSTOTAL01 ELSE 0 END;
			REC.COSTOUT := CASE WHEN I.INOUT = 2 THEN I.COSTOTAL01 ELSE 0 END;
			REC.COSTEND := REC.COSTBEGIN + REC.COSTIN - REC.COSTOUT;
		ELSE
			REC.COSTIN := CASE WHEN I.INOUT = 1 THEN I.COSTOTAL02 ELSE 0 END;
			REC.COSTOUT := CASE WHEN I.INOUT = 2 THEN I.COSTOTAL02 ELSE 0 END;
			REC.COSTEND := REC.COSTBEGIN + REC.COSTIN - REC.COSTOUT;
		END IF;

		REC.COSTAVGBEGIN := CASE WHEN REC.STOCKBEGIN = 0 THEN 0 ELSE REC.COSTBEGIN / REC.STOCKBEGIN END;
		REC.COSTAVGIN := CASE WHEN REC.STOCKIN = 0 THEN 0 ELSE REC.COSTIN / REC.STOCKIN END;
		REC.COSTAVGOUT := CASE WHEN REC.STOCKOUT = 0 THEN 0 ELSE REC.COSTOUT / REC.STOCKOUT END;
		REC.COSTAVGEND := CASE WHEN REC.STOCKEND = 0 THEN 0 ELSE REC.COSTEND / REC.STOCKEND END;

		RETURN NEXT REC;

	END LOOP;
	
END;
$BODY$
LANGUAGE plpgsql;